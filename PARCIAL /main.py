# main.py - VERSI√ìN SIN REPORTES DUPLICADOS
# Corrige el problema de reportes que se imprimen dos veces
from lexicoo import Lexico
from arbolito import AnalizadorSintacticoLL, imprimir_tabla
from semantico import Semantico
from error_manager import get_error_manager, reset_error_manager, ErrorType, ErrorSeverity
import os
import sys
# VARIABLE GLOBAL para evitar ejecuci√≥n m√∫ltiple
_main_ejecutado = False
def main():
    """
    Funci√≥n principal del compilador con manejo completo de errores.
    CORREGIDO: Solo ejecuta y reporta una vez.
    """
    global _main_ejecutado
    
    # Evitar ejecuci√≥n m√∫ltiple
    if _main_ejecutado:
        return True
    
    _main_ejecutado = True
    
    # Reiniciar el gestor de errores para una nueva compilaci√≥n
    error_mgr = reset_error_manager()
    error_mgr.set_debug_mode(False)  # Cambiar a True para debug detallado
    
    print("üöÄ COMPILADOR CON MANEJO DE ERRORES ROBUSTO")
    print("=" * 60)
    
    compilacion_exitosa = False
    
    try:
        # Configuraci√≥n de archivos
        archivo_fuente = "codigo_fuente.txt"
        archivo_tabla = "tabla_ll1.csv"
        
        error_mgr.set_execution_phase("INICIALIZACI√ìN")
        
        # Verificar archivos necesarios
        if not verificar_archivos_necesarios(error_mgr, archivo_fuente, archivo_tabla):
            return generar_reporte_final_unico(error_mgr, False, "INICIALIZACI√ìN")
        
        # ETAPA 1: An√°lisis l√©xico
        error_mgr.set_execution_phase("AN√ÅLISIS L√âXICO")
        print("\n=== ETAPA 1: AN√ÅLISIS L√âXICO ===")
        
        tokens = ejecutar_analisis_lexico(error_mgr, archivo_fuente)
        if tokens is None:
            return generar_reporte_final_unico(error_mgr, False, "AN√ÅLISIS L√âXICO")
        
        # ETAPA 2: An√°lisis sint√°ctico
        error_mgr.set_execution_phase("AN√ÅLISIS SINT√ÅCTICO")
        print("\n=== ETAPA 2: AN√ÅLISIS SINT√ÅCTICO ===")
        
        resultado_sintactico = ejecutar_analisis_sintactico(error_mgr, tokens, archivo_tabla)
        if resultado_sintactico is None:
            return generar_reporte_final_unico(error_mgr, False, "AN√ÅLISIS SINT√ÅCTICO")
        
        # ETAPA 3: An√°lisis sem√°ntico
        error_mgr.set_execution_phase("AN√ÅLISIS SEM√ÅNTICO")
        print("\n=== ETAPA 3: AN√ÅLISIS SEM√ÅNTICO ===")
        
        tabla_simbolos = ejecutar_analisis_semantico(error_mgr, tokens, resultado_sintactico['arbol'])
        if tabla_simbolos is None:
            return generar_reporte_final_unico(error_mgr, False, "AN√ÅLISIS SEM√ÅNTICO")
        
        # ETAPA 4: Generaci√≥n de archivos de salida
        error_mgr.set_execution_phase("GENERACI√ìN DE SALIDA")
        print("\n=== ETAPA 4: GENERACI√ìN DE ARCHIVOS ===")
        
        generar_archivos_salida(error_mgr, resultado_sintactico, tabla_simbolos)
        
        compilacion_exitosa = True
        
    except KeyboardInterrupt:
        error_mgr.add_error(
            ErrorType.SISTEMA,
            ErrorSeverity.ERROR,
            "Compilaci√≥n interrumpida por el usuario (Ctrl+C)",
            "Sistema",
            suggestion="Espera a que termine o usa 'exit()' si est√°s en modo interactivo"
        )
        print("\n‚ö†Ô∏è Compilaci√≥n interrumpida por el usuario")
        
    except MemoryError:
        error_mgr.add_error(
            ErrorType.SISTEMA,
            ErrorSeverity.CRITICO,
            "Sin memoria suficiente para completar la compilaci√≥n",
            "Sistema",
            suggestion="Cierra otros programas o usa un archivo de c√≥digo m√°s peque√±o"
        )
        
    except Exception as e:
        error_mgr.add_error(
            ErrorType.SISTEMA,
            ErrorSeverity.CRITICO,
            f"Error inesperado del sistema: {str(e)}",
            "Sistema",
            exception=e,
            suggestion="Reporta este error al desarrollador con el c√≥digo que caus√≥ el problema"
        )
        
    finally:
        # Generar reporte final SOLO UNA VEZ
        fase_final = error_mgr.execution_phase if hasattr(error_mgr, 'execution_phase') else "DESCONOCIDA"
        return generar_reporte_final_unico(error_mgr, compilacion_exitosa, fase_final)
def verificar_archivos_necesarios(error_mgr, archivo_fuente, archivo_tabla):
    """Verifica que todos los archivos necesarios existan."""
    archivos_ok = True
    
    # Verificar archivo de c√≥digo fuente
    if not os.path.exists(archivo_fuente):
        error_mgr.add_file_error(
            f"No se encontr√≥ el archivo de c√≥digo fuente: {archivo_fuente}",
            archivo_fuente,
            f"Crea el archivo {archivo_fuente} con tu c√≥digo fuente"
        )
        archivos_ok = False
    elif os.path.getsize(archivo_fuente) == 0:
        error_mgr.add_file_error(
            f"El archivo de c√≥digo fuente est√° vac√≠o: {archivo_fuente}",
            archivo_fuente,
            f"Agrega c√≥digo fuente al archivo {archivo_fuente}"
        )
        archivos_ok = False
    
    # Verificar tabla LL1 (opcional pero recomendada)
    if not os.path.exists(archivo_tabla):
        error_mgr.add_warning(
            f"No se encontr√≥ la tabla LL1: {archivo_tabla}",
            "Sistema de archivos",
            suggestion=f"Crea el archivo {archivo_tabla} para an√°lisis sint√°ctico completo"
        )
        # No es cr√≠tico, continuamos
    
    return archivos_ok
def ejecutar_analisis_lexico(error_mgr, archivo_fuente):
    """Ejecuta el an√°lisis l√©xico con manejo de errores."""
    try:
        lexer = Lexico()
        
        # Cargar c√≥digo fuente
        codigo = lexer.cargar_desde_archivo(archivo_fuente)
        if not codigo:
            error_mgr.add_file_error(
                f"No se pudo leer el contenido del archivo: {archivo_fuente}",
                archivo_fuente,
                "Verifica que el archivo exista y tenga permisos de lectura"
            )
            return None
        
        print(f"üìÑ C√≥digo fuente le√≠do: {len(codigo)} caracteres")
        print(f"   Primeras l√≠neas: {repr(codigo[:100])}...")
        
        # Analizar tokens
        tokens = lexer.analizar(codigo)
        
        if hasattr(lexer, 'errores') and lexer.errores:
            print(f"\n‚ùå Se encontraron {len(lexer.errores)} errores l√©xicos:")
            for i, error in enumerate(lexer.errores, 1):
                print(f"   {i}. {error}")
                error_mgr.add_lexical_error(
                    str(error),
                    suggestion="Revisa la sintaxis del c√≥digo fuente"
                )
            return None
        
        print(f"‚úÖ An√°lisis l√©xico exitoso: {len(tokens)} tokens generados")
        
        # Mostrar resumen de tokens
        if tokens:
            tipos_token = {}
            for token in tokens:
                tipo = token.getToken()
                tipos_token[tipo] = tipos_token.get(tipo, 0) + 1
            
            print(f"üìä Tipos de tokens: {len(tipos_token)} diferentes")
            print("   Los m√°s frecuentes:", end="")
            for tipo, count in sorted(tipos_token.items(), key=lambda x: x[1], reverse=True)[:5]:
                print(f" {tipo}({count})", end="")
            print()
        
        return tokens
        
    except ImportError as e:
        error_mgr.add_error(
            ErrorType.SISTEMA,
            ErrorSeverity.CRITICO,
            f"Error importando el analizador l√©xico: {str(e)}",
            "Analizador L√©xico",
            exception=e,
            suggestion="Verifica que el archivo lexicoo.py est√© en el directorio actual"
        )
        return None
        
    except Exception as e:
        error_mgr.add_error(
            ErrorType.LEXICO,
            ErrorSeverity.CRITICO,
            f"Error inesperado en an√°lisis l√©xico: {str(e)}",
            "Analizador L√©xico",
            exception=e,
            suggestion="Revisa la sintaxis del c√≥digo fuente"
        )
        return None
def ejecutar_analisis_sintactico(error_mgr, tokens, archivo_tabla):
    """Ejecuta el an√°lisis sint√°ctico con manejo de errores."""
    try:
        # Preparar lista de tokens
        lista_tokens = [token.getToken() for token in tokens]
        print(f"üîó Tokens a analizar: {' '.join(lista_tokens[:10])}{'...' if len(lista_tokens) > 10 else ''}")
        
        # Crear analizador sint√°ctico
        analizador = AnalizadorSintacticoLL(archivo_tabla)
        
        # Ejecutar an√°lisis
        resultado = analizador.analizar(lista_tokens)
        
        # Verificar resultado
        if not resultado:
            error_mgr.add_syntax_error(
                "El analizador sint√°ctico no devolvi√≥ resultado",
                suggestion="Verifica la tabla LL1 y la gram√°tica"
            )
            return None
        
        if resultado.get('CONCLUSION') != "ACEPTADO :)":
            mensaje_error = resultado.get('mensaje', 'Error sint√°ctico desconocido')
            error_mgr.add_syntax_error(
                mensaje_error,
                suggestion="Revisa que la estructura del c√≥digo coincida con la gram√°tica"
            )
            
            # Mostrar detalles del error si est√°n disponibles
            if 'pasos' in resultado and resultado['pasos']:
                print("\nüîç Pasos del an√°lisis hasta el error:")
                pasos = resultado['pasos'][-5:]  # √öltimos 5 pasos
                for paso in pasos:
                    print(f"   {paso}")
            
            return None
        
        print("‚úÖ An√°lisis sint√°ctico exitoso")
        
        # Mostrar estad√≠sticas si est√°n disponibles
        if 'estadisticas' in resultado:
            stats = resultado['estadisticas']
            print(f"üìä Estad√≠sticas: {stats.get('nodos_creados', 0)} nodos, {stats.get('producciones_aplicadas', 0)} producciones")
        
        # Generar archivo DOT si es posible
        if resultado.get('graphviz_code'):
            try:
                with open("arbol_sintactico.dot", "w", encoding="utf-8") as f:
                    f.write(resultado['graphviz_code'])
                print("üìä Archivo 'arbol_sintactico.dot' generado")
            except Exception as e:
                error_mgr.add_warning(
                    f"No se pudo generar archivo DOT: {str(e)}",
                    "Generador de gr√°ficos",
                    suggestion="Esto no afecta la compilaci√≥n, es solo para visualizaci√≥n"
                )
        
        return resultado
        
    except FileNotFoundError:
        error_mgr.add_file_error(
            f"No se encontr√≥ la tabla LL1: {archivo_tabla}",
            archivo_tabla,
            "Usa un √°rbol sint√°ctico simulado o crea la tabla LL1"
        )
        
        # Intentar usar √°rbol simulado
        try:
            from arbolito import Node
            print("‚ö†Ô∏è Usando √°rbol sint√°ctico simulado para continuar")
            return {
                'CONCLUSION': "ACEPTADO :)",
                'arbol': Node('PROGRAMA'),
                'mensaje': 'An√°lisis simulado exitoso',
                'graphviz_code': None
            }
        except Exception:
            error_mgr.add_syntax_error(
                "No se pudo crear √°rbol sint√°ctico simulado",
                suggestion="Verifica que el archivo arbolito.py est√© disponible"
            )
            return None
            
    except Exception as e:
        error_mgr.add_error(
            ErrorType.SINTACTICO,
            ErrorSeverity.CRITICO,
            f"Error inesperado en an√°lisis sint√°ctico: {str(e)}",
            "Analizador Sint√°ctico",
            exception=e,
            suggestion="Verifica la gram√°tica y la tabla LL1"
        )
        return None
def ejecutar_analisis_semantico(error_mgr, tokens, arbol):
    """Ejecuta el an√°lisis sem√°ntico con manejo de errores."""
    try:
        semantico = Semantico()
        
        # Construir tabla de s√≠mbolos
        tabla_simbolos = semantico.construir_tabla_simbolos(tokens, arbol)
        
        if not tabla_simbolos:
            error_mgr.add_semantic_error(
                "No se pudo crear la tabla de s√≠mbolos",
                suggestion="Verifica que el c√≥digo tenga declaraciones v√°lidas"
            )
            return None
        
        if not hasattr(tabla_simbolos, 'tabla') or not tabla_simbolos.tabla:
            error_mgr.add_semantic_error(
                "La tabla de s√≠mbolos est√° vac√≠a",
                suggestion="Verifica que el c√≥digo tenga declaraciones de variables o funciones"
            )
            return None
        
        print(f"‚úÖ An√°lisis sem√°ntico exitoso: {len(tabla_simbolos.tabla)} s√≠mbolos")
        
        # Mostrar tabla de s√≠mbolos
        if hasattr(tabla_simbolos, 'imprimir_tabla_mejorada'):
            tabla_simbolos.imprimir_tabla_mejorada()
        else:
            tabla_simbolos.imprimir_tabla()
        
        # Validar tabla de s√≠mbolos
        if hasattr(tabla_simbolos, 'validar_tabla'):
            if tabla_simbolos.validar_tabla():
                print("üîç Validaci√≥n: ‚úÖ Tabla de s√≠mbolos v√°lida")
            else:
                error_mgr.add_warning(
                    "La tabla de s√≠mbolos tiene inconsistencias menores",
                    "Validador sem√°ntico",
                    suggestion="Revisa las declaraciones duplicadas o tipos inconsistentes"
                )
        
        return tabla_simbolos
        
    except ImportError as e:
        error_mgr.add_error(
            ErrorType.SISTEMA,
            ErrorSeverity.CRITICO,
            f"Error importando el analizador sem√°ntico: {str(e)}",
            "Analizador Sem√°ntico",
            exception=e,
            suggestion="Verifica que los archivos semantico.py y tabla_simbolos.py est√©n disponibles"
        )
        return None
        
    except Exception as e:
        error_mgr.add_error(
            ErrorType.SEMANTICO,
            ErrorSeverity.CRITICO,
            f"Error inesperado en an√°lisis sem√°ntico: {str(e)}",
            "Analizador Sem√°ntico",
            exception=e,
            suggestion="Revisa las declaraciones de variables y funciones"
        )
        return None
def generar_archivos_salida(error_mgr, resultado_sintactico, tabla_simbolos):
    """Genera archivos de salida con manejo de errores."""
    archivos_generados = 0
    
    # Generar tabla de s√≠mbolos
    try:
        with open("tabla_simbolos.txt", "w", encoding="utf-8") as f:
            original_stdout = sys.stdout
            sys.stdout = f
            if hasattr(tabla_simbolos, 'imprimir_tabla'):
                tabla_simbolos.imprimir_tabla()
            sys.stdout = original_stdout
        
        print("üíæ Tabla de s√≠mbolos guardada en 'tabla_simbolos.txt'")
        archivos_generados += 1
        
    except Exception as e:
        error_mgr.add_warning(
            f"No se pudo guardar tabla de s√≠mbolos: {str(e)}",
            "Generador de archivos",
            suggestion="Verifica permisos de escritura en el directorio"
        )
    
    # Generar estad√≠sticas
    try:
        if hasattr(tabla_simbolos, 'obtener_estadisticas'):
            stats = tabla_simbolos.obtener_estadisticas()
            print(f"\nüìà ESTAD√çSTICAS FINALES:")
            print(f"   ‚Ä¢ S√≠mbolos totales: {stats.get('total_simbolos', 0)}")
            print(f"   ‚Ä¢ Variables: {stats.get('variables', 0)}")
            print(f"   ‚Ä¢ Funciones: {stats.get('funciones', 0)}")
            
    except Exception as e:
        error_mgr.add_warning(
            f"No se pudieron generar estad√≠sticas: {str(e)}",
            "Generador de estad√≠sticas"
        )
    
    if archivos_generados > 0:
        print(f"üìÅ {archivos_generados} archivo(s) de salida generado(s)")
def generar_reporte_final_unico(error_mgr, compilacion_exitosa, fase_fallo):
    """
    Genera el reporte final de errores y resultados.
    CORREGIDO: Solo se ejecuta una vez, no duplica reportes.
    """
    # Marcar que ya se gener√≥ el reporte para evitar duplicaci√≥n
    if hasattr(error_mgr, '_reporte_generado') and error_mgr._reporte_generado:
        return compilacion_exitosa and not error_mgr.has_errors()
    
    error_mgr._reporte_generado = True
    
    print("\n" + "=" * 60)
    print("üìã REPORTE FINAL DE COMPILACI√ìN")
    print("=" * 60)
    
    if compilacion_exitosa and not error_mgr.has_errors():
        print("üéâ ¬°COMPILACI√ìN COMPLETAMENTE EXITOSA!")
        print("‚úÖ No se encontraron errores")
        if error_mgr.errors:  # Solo advertencias
            print(f"‚ö†Ô∏è Se encontraron {len(error_mgr.errors)} advertencia(s)")
    elif compilacion_exitosa and error_mgr.has_errors():
        print("‚ö†Ô∏è COMPILACI√ìN COMPLETADA CON ADVERTENCIAS")
        print("‚úÖ Compilaci√≥n t√©cnicamente exitosa")
        print("‚ö†Ô∏è Hay advertencias que deber√≠as revisar")
    else:
        print("‚ùå COMPILACI√ìN FALLIDA")
        print(f"üõë Fall√≥ en fase: {fase_fallo}")
        if error_mgr.has_critical_errors():
            print("üî¥ Se encontraron errores cr√≠ticos")
    
    # Mostrar reporte de errores detallado SOLO SI HAY ERRORES
    if error_mgr.errors:
        reporte = error_mgr.generate_error_report()
        print(f"\n{reporte}")
        
        # Guardar log de errores
        try:
            if error_mgr.save_error_log():
                print(f"\nüíæ Log detallado guardado en 'compilador_errores.log'")
        except Exception:
            pass  # No es cr√≠tico si no se puede guardar
    
    print("\n" + "=" * 60)
    
    return compilacion_exitosa and not error_mgr.has_errors()
# IMPORTANTE: Evitar que se ejecute m√∫ltiples veces
if __name__ == "__main__":
    try:
        exito = main()
        sys.exit(0 if exito else 1)
    except Exception as e:
        print(f"\nüí• ERROR FATAL DEL SISTEMA: {e}")
        sys.exit(2)
